ğŸ•µï¸ Shadow Bind â€” Reverse Engineering Write-Up

When I first ran the binary, everything looked normal.
No crash, no input prompt, no flag â€” just a basic integrity check message and exit.

At this point, it was clear this challenge was hiding something deeper.

ğŸ” Step 1: Spotting the Trick (Dynamic Library)

Using ldd, I noticed the program was loading a shared object:

libshadow.so


This immediately hinted that the real logic might not be inside the main binary.

So instead of wasting time reversing shadow_core fully, I shifted focus to the library.

ğŸ“š Step 2: Reversing the Library

Opening libshadow.so in a disassembler showed something interesting:

The library was:

â€¢ Opening /proc/self/exe
â€¢ Reading bytes from its own running binary
â€¢ Jumping behavior based on what it read

In short â€” the program was inspecting itself.

This is a classic self-integrity / self-inspection trick.

ğŸ§  Step 3: Finding the Hidden Condition

Digging deeper, I found:

The library seeks to:

offset 0x3000


Then reads 6 bytes and compares them to:

CHROMA

âœ” If match â†’ secret function runs
âŒ If not â†’ normal execution

The secret function decrypted and printed the flag.

ğŸ§ª Step 4: Why It Never Triggered

Checking the binary at offset 0x3000 showed:

00 00 00 00 00 00


So the condition could never be true.

The program was designed to never reach the hidden path unless patched.

ğŸ›  Step 5: Triggering the Secret Path

I patched the binary:

At offset 0x3000, replaced null bytes with:

CHROMA


Saved the file and ran it again.

ğŸ‰ Step 6: Flag Revealed

The hidden function executed and printed:

SECE{sh4d0w_b1nd_dyn4m1c_r3s0lv3}

âœ… Final Flag

SECE{sh4d0w_b1nd_dyn4m1c_r3s0lv3}


Here is my GPT chat
https://chatgpt.com/share/697c87bc-d05c-8005-8970-990e613ba32f
